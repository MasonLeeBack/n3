//=============================================================================
//
// 	Token.h   
//
// 	Author:	 James Boer
//
//	Copyright (C) 2001 James R. Boer  All Rights Reserved.
//	
//=============================================================================
#pragma once

#ifndef __TOKEN_H
#define __TOKEN_H

//#ifdef _DEBUG
#define TOKEN_DEBUGGING_INFO
//#endif

// Required for GUID definition

#ifdef _WINDOWS
#include <windows.h>
#include "BsUtil.h"
#endif

#include <vector>
#include <list>


class BStream;


// This is the basic data object generated by the Parser class
class Token 
{
public:
	enum TOKEN_TYPE
	{
		UNKNOWN_TOKEN = 0,
		KEYWORD,
		OPERATOR,
		VARIABLE,
		STRING,
		INTEGER,
		REAL,
		BOOLEAN,
		T_GUID
	};


	Token()						{  Clear();  }
	Token(const Token& tok);
	virtual ~Token()			{  Destroy();  }
	void Clear();

	bool Save( BStream* pStream );
	bool Load( BStream* pStream );

	void operator = ( const Token& tok);

	inline bool CreateKeyword(const char* pszKeyword)
	{
		m_Type = KEYWORD;
		const size_t pszKeyword_len = strlen(pszKeyword) + 1; //aleksger - safe string
		m_pszKeyword = new char[pszKeyword_len];
		if(!m_pszKeyword)
			return false;
		strcpy_s(m_pszKeyword, pszKeyword_len, pszKeyword);
		return true;
	}

	inline bool CreateOperator(const char* pszOperator)
	{
		m_Type = OPERATOR;
		const size_t pszOperator_len = strlen(pszOperator) + 1; //aleksger - safe string
		m_pszOperator = new char[pszOperator_len];
		if(!m_pszOperator)
			return false;
		strcpy_s(m_pszOperator, pszOperator_len, pszOperator);
		return true;
	}

	inline bool CreateVariable(const char* pszVariable)
	{
		m_Type = VARIABLE;
		const size_t pszVariable_len = strlen(pszVariable) + 1; //aleksger - safe string
		m_pszVariable = new char[pszVariable_len];
		if(!m_pszVariable)
			return false;
		strcpy_s(m_pszVariable, pszVariable_len, pszVariable);
		return true;
	}

	inline bool CreateString(const char* pszString)
	{
		m_Type = STRING;
		const size_t pszString_len = strlen(pszString) + 1; //aleksger - safe string
		m_pszString = new char[pszString_len];
		if(!m_pszString)
			return false;
		strcpy_s(m_pszString, pszString_len, pszString);
		return true;
	}

	inline bool CreateInteger(int iInteger)
	{
		m_Type = INTEGER;
		m_iInteger = iInteger;
		return true;
	}

	inline bool CreateReal(float fReal)
	{
		m_Type = REAL;
		m_fReal = fReal;
		return true;
	}

	inline bool CreateBoolean(bool bBoolean)
	{
		m_Type = BOOLEAN;
		m_bBoolean = bBoolean;
		return true;
	}

	inline bool CreateGuid(const GUID& guidGuid)
	{
		m_Type = T_GUID;
		m_pguidGuid = new GUID;
		if(!m_pguidGuid)
			return false;
		memcpy(m_pguidGuid, &guidGuid, sizeof(GUID));
		return true;
	}

	void Destroy();

	inline void SetVariable(const char* pszVariable)
	{
		BsAssert(m_Type == VARIABLE);
		delete[] m_pszVariable;
		m_pszVariable = 0;
		CreateVariable(pszVariable);
	}

	inline void SetKeyword(const char* pszKeyword)
	{
		BsAssert(m_Type == KEYWORD);
		delete[] m_pszKeyword;
		m_pszKeyword = 0;
		CreateKeyword(pszKeyword);
	}

	inline void SetString(const char* pszString)
	{
		BsAssert(m_Type == STRING);
		delete[] m_pszString;
		m_pszString = 0;
		CreateString(pszString);
	}

	inline void SetOperator(const char* pszOperator)
	{
		BsAssert(m_Type == OPERATOR);
		delete[] m_pszOperator;
		m_pszOperator = 0;
		CreateOperator(pszOperator);
	}

	inline void SetInteger(const int iInteger)
	{
		BsAssert(m_Type == INTEGER);
		CreateInteger(iInteger);
	}

	inline void SetBoolean(const bool bBoolean)
	{
		BsAssert(m_Type == BOOLEAN);
		CreateBoolean(bBoolean);
	}

	inline void SetReal(const float fReal)
	{
		BsAssert(m_Type == REAL);
		CreateReal(fReal);
	}

	inline void SetGuid(const GUID& guidGuid)
	{
		BsAssert(m_Type == T_GUID);
		delete m_pguidGuid;
		m_pguidGuid = 0;
		CreateGuid(guidGuid);
	}

	// querry the type of token
	inline bool IsUnknown()	const		{  return (m_Type == UNKNOWN_TOKEN) ? true : false;  }
	inline bool IsKeyword()	const		{  return (m_Type == KEYWORD) ? true : false;  }
	inline bool IsOperator() const		{  return (m_Type == OPERATOR) ? true : false;  }
	inline bool IsVariable() const		{  return (m_Type == VARIABLE) ? true : false;  }
	inline bool IsString() const		{  return (m_Type == STRING) ? true : false;  }
	inline bool IsInteger()	const		{  return (m_Type == INTEGER) ? true : false;  }
	inline bool IsReal() const			{  return (m_Type == REAL) ? true : false;  }
	inline bool IsBoolean()	const		{  return (m_Type == BOOLEAN) ? true : false;  }
	inline bool IsGuid() const			{  return (m_Type == T_GUID) ? true : false;  }
	inline TOKEN_TYPE GetType() const	{  return m_Type;  }

	// get the token content
	inline const char* GetKeyword() const	{  BsAssert(m_Type == KEYWORD);  return (const char*)m_pszKeyword;  }
	inline const char* GetOperator() const	{  BsAssert(m_Type == OPERATOR);  return (const char*)m_pszOperator;  }
	inline const char* GetVariable() const	{  BsAssert(m_Type == VARIABLE);  return (const char*)m_pszVariable;  }
	inline const char* GetString() const	{  BsAssert(m_Type == STRING);  return (const char*)m_pszString;  }
	inline int GetInteger() const			{  BsAssert(m_Type == INTEGER);  return m_iInteger;  }
	inline float GetReal() const			{  BsAssert(m_Type == REAL);  return m_fReal;  }
	inline bool GetBoolean() const			{  BsAssert(m_Type == BOOLEAN);  return m_bBoolean;  }
	inline GUID& GetGuid() const			{  BsAssert(m_Type == T_GUID);  return *m_pguidGuid;  }

	inline const char* GetText()
	{
		static char buffer[1024];		// 않좋은 형태지만, 일단 씁시다...--
		switch (GetType())
		{
		case KEYWORD: return m_pszKeyword;
		case OPERATOR: return m_pszOperator;
		case VARIABLE: return m_pszVariable;
		case STRING: return m_pszString;
		case INTEGER: _itoa(m_iInteger, buffer, 10); return buffer;
		case REAL: sprintf(buffer, "%f", m_fReal); return buffer;
		case BOOLEAN: return (m_bBoolean) ? "true" : "false";
		case T_GUID: sprintf(buffer, "0xI64x%x", m_pguidGuid->Data1); return buffer;
		}

		BsAssert(false);
		return NULL;
	}

	inline bool IsNewline() const			{  return (IsOperator() && (GetOperator()[0] == '\n')) ? true : false;  }

	const char* GetDescriptiveString() const;
	
#ifdef TOKEN_DEBUGGING_INFO
	inline void SetLineNumber(int iLineNo)	{  m_iLineNumber = iLineNo;  }
	inline int GetLineNumber() const		{  return m_iLineNumber;  }
	inline void SetFileIndex(int iIndex)	{  m_iFileIndex = iIndex;  }
	inline int GetFileIndex() const			{  return m_iFileIndex;  }
#else
	inline int GetLineNumber() const		{  return 0;  }
#endif // TOKEN_DEBUGGING_INFO


protected:

	// This tells us which type of data we're carrying
	TOKEN_TYPE m_Type;

	// The data is in one of these fields.  We're only going to be using
	// one type per token, so no reason to waste space.  So, we make
	// the data fields part of a union.
	union
	{
		char*			m_pszKeyword;
		char*			m_pszOperator;
		char*			m_pszVariable;
		char*			m_pszString;
		int				m_iInteger;
		float			m_fReal;
		bool			m_bBoolean;
		GUID*			m_pguidGuid;
	};

#ifdef TOKEN_DEBUGGING_INFO
	// Indicates the line number in which the token was found.
	// Note that although this is debugging information, it should
	// not only be contained in debug builds, since we may want to
	// "debug" release mode applications which still will be using
	// this parser.
	int m_iLineNumber;

	// References an index into a string table containing the source
	// file in which this token was found.
	int m_iFileIndex;
#endif // TOKEN_DEBUGGING_INFO

};

// stream operators
// this is to support a tokenized file representation of a parsed file
inline std::ostream& operator<<( std::ostream& os, Token& tok );
inline std::istream& operator>>( std::istream& is, Token& tok );


typedef std::vector<std::string> StringVector;
typedef std::vector<Token> TokenVector;
typedef std::vector<Token> TokenVector;

typedef std::list<Token>::iterator TokenListItor;




// TokenList is the standard list type for tokens.  It's a basic STL list
// of type token with some enhancements for storing and retrieving debugging info
class TokenList : public std::list<Token>
{
public:

	// Gets a descriptive string of the token including file name and line number
	std::string GetDescriptiveString(TokenListItor itr) const;
	// Gets a string of the file name from where the token was parsed
	//std::string GetFileName(TokenListItor itr) const;
	std::string GetFileName(int index) const;
	// Gets the line number of the token
	int GetLineNumber(TokenListItor itr) const;
	
	// Given a filename, find the index into the filelist vector.  If it doesn't
	// currently exist in the vector, push it onto the end and return the
	// new index value.
	int GetFileIndex(const std::string & sFileName);//aleksger: prefix bug 873: Pass strings by reference

	// Get the total number of file references in this token list
	int GetNumFileRefs() const;

	void clear();
	
private:
	StringVector m_aFileRef;
};




// 소스가 txt, bin 둘다 호환되게 하기 위해, 바이너리 저장을 쉽게 하기 위해 만듬
class TokenBuffer
{
public:
	TokenBuffer();
	~TokenBuffer();

	void Clear();

	Token& operator ++();
	Token operator ++(int);
	Token& operator --();
	Token operator --(int);
	void Initialize( TokenList* pList );

	bool Save( char* pFileName, int nTime = -1 );
	bool Load( char* pFileName, int nTime = -1 );

	bool IsEnd()		{ return m_nNumToken == m_nCurIndex; }

	// querry the type of token
	inline bool IsUnknown()			{  return m_pToken[m_nCurIndex].IsUnknown();  }
	inline bool IsKeyword()			{  return m_pToken[m_nCurIndex].IsKeyword();  }
	inline bool IsOperator()		{  return m_pToken[m_nCurIndex].IsOperator();  }
	inline bool IsVariable()		{  return m_pToken[m_nCurIndex].IsVariable();  }
	inline bool IsString()			{  return m_pToken[m_nCurIndex].IsString();  }
	inline bool IsInteger()			{  return m_pToken[m_nCurIndex].IsInteger();  }
	inline bool IsReal()			{  return m_pToken[m_nCurIndex].IsReal();  }
	inline bool IsBoolean()			{  return m_pToken[m_nCurIndex].IsBoolean();  }
	inline bool IsGuid()			{  return m_pToken[m_nCurIndex].IsGuid();  }
	inline Token::TOKEN_TYPE GetType()		{  return m_pToken[m_nCurIndex].GetType();  }

	// get the token content
	inline const char* GetKeyword() const	{  return m_pToken[m_nCurIndex].GetKeyword(); }
	inline const char* GetOperator() const	{  return m_pToken[m_nCurIndex].GetOperator(); }
	inline const char* GetVariable() const	{  return m_pToken[m_nCurIndex].GetVariable(); }
	inline const char* GetString() const	{  return m_pToken[m_nCurIndex].GetString(); }
	inline int GetInteger() const			{  return m_pToken[m_nCurIndex].GetInteger(); }
	inline float GetReal() const			{  return m_pToken[m_nCurIndex].GetReal(); }
	inline bool GetBoolean() const			{  return m_pToken[m_nCurIndex].GetBoolean(); }
	inline GUID& GetGuid() const			{  return m_pToken[m_nCurIndex].GetGuid(); }

	inline int GetLineNumber() const		{  return m_pToken[m_nCurIndex].GetLineNumber(); }

	std::string GetFileName(int index) const;
	int TokenBuffer::GetFileIndex(const std::string &sFileName) const; //aleksger: prefix bug 872: Pass strings by reference
	int GetNumFileRefs() const;
	std::string GetDescriptiveString();

	inline const char* GetText()	{ return m_pToken[m_nCurIndex].GetText(); }

protected:

	int m_nNumToken;
	int m_nCurIndex;
	Token* m_pToken;

	int m_nNumFileRef;
	std::string* m_pFileRef;
};



#endif // __TOKEN_H